/*
          # Create Profiles Table
          This table stores public user data and preferences, linked to Supabase's authentication system.

          ## Query Description: "This operation creates the main 'profiles' table to store user-specific information like theme and font size preferences. It is designed to automatically populate with a new entry whenever a user signs up. This is a foundational and safe operation."
          
          ## Metadata:
          - Schema-Category: "Structural"
          - Impact-Level: "Low"
          - Requires-Backup: false
          - Reversible: true
          
          ## Structure Details:
          - Table: public.profiles
          - Columns: id, updated_at, theme, font_size
          
          ## Security Implications:
          - RLS Status: Enabled
          - Policy Changes: Yes
          - Auth Requirements: Users can only view and update their own profile.
          
          ## Performance Impact:
          - Indexes: Primary key on 'id'.
          - Triggers: A trigger is added to 'auth.users' to populate this table.
          - Estimated Impact: Low, standard setup for user profiles.
          */
CREATE TABLE public.profiles (
    id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    theme TEXT DEFAULT 'light' CHECK (theme IN ('light', 'dark')),
    font_size TEXT DEFAULT 'base' CHECK (font_size IN ('sm', 'base', 'lg', 'xl'))
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public profiles are viewable by everyone."
ON public.profiles FOR SELECT
USING (true);

CREATE POLICY "Users can insert their own profile."
ON public.profiles FOR INSERT
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update their own profile."
ON public.profiles FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

/*
          # Create Profile on User Signup
          This function and trigger automatically create a new profile entry when a new user signs up.

          ## Query Description: "This operation sets up an automated process to create a user profile upon registration. It ensures that every authenticated user has a corresponding entry in the 'profiles' table. This is a safe and standard procedure for managing user data."
          
          ## Metadata:
          - Schema-Category: "Structural"
          - Impact-Level: "Low"
          - Requires-Backup: false
          - Reversible: true
          
          ## Structure Details:
          - Function: public.handle_new_user
          - Trigger: on_auth_user_created
          
          ## Security Implications:
          - RLS Status: Not applicable to trigger function.
          - Policy Changes: No
          - Auth Requirements: Runs with definer security to insert into profiles table.
          
          ## Performance Impact:
          - Indexes: None
          - Triggers: Adds a trigger to 'auth.users' table.
          - Estimated Impact: Negligible impact on user signup performance.
          */
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  INSERT INTO public.profiles (id)
  VALUES (new.id);
  RETURN new;
END;
$$;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

/*
          # Create Progress Table
          This table tracks which days of the journey a user has completed.

          ## Query Description: "This operation creates the 'progress' table to log user completion of daily chapters. RLS policies ensure that each user can only manage their own progress data. This is a safe, data-centric operation."
          
          ## Metadata:
          - Schema-Category: "Data"
          - Impact-Level: "Low"
          - Requires-Backup: false
          - Reversible: true
          
          ## Structure Details:
          - Table: public.progress
          - Columns: id, user_id, day_id, created_at
          
          ## Security Implications:
          - RLS Status: Enabled
          - Policy Changes: Yes
          - Auth Requirements: Users can only create, view, and delete their own progress entries.
          
          ## Performance Impact:
          - Indexes: Primary key and a unique index on (user_id, day_id).
          - Triggers: None
          - Estimated Impact: Low, standard CRUD operations.
          */
CREATE TABLE public.progress (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  day_id INT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, day_id)
);

ALTER TABLE public.progress ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own progress."
ON public.progress FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own progress."
ON public.progress FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own progress."
ON public.progress FOR DELETE
USING (auth.uid() = user_id);

/*
          # Create Favorites Table
          This table stores which chapters a user has marked as a favorite.

          ## Query Description: "This operation creates the 'favorites' table. It allows users to bookmark chapters and is secured by RLS policies so that a user's favorites are private. This is a safe, data-centric operation."
          
          ## Metadata:
          - Schema-Category: "Data"
          - Impact-Level: "Low"
          - Requires-Backup: false
          - Reversible: true
          
          ## Structure Details:
          - Table: public.favorites
          - Columns: id, user_id, day_id, created_at
          
          ## Security Implications:
          - RLS Status: Enabled
          - Policy Changes: Yes
          - Auth Requirements: Users can only manage their own favorites.
          
          ## Performance Impact:
          - Indexes: Primary key and a unique index on (user_id, day_id).
          - Triggers: None
          - Estimated Impact: Low, standard CRUD operations.
          */
CREATE TABLE public.favorites (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  day_id INT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, day_id)
);

ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own favorites."
ON public.favorites FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own favorites."
ON public.favorites FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own favorites."
ON public.favorites FOR DELETE
USING (auth.uid() = user_id);

/*
          # Create Notes Table
          This table stores the user's personal journal entries for each day.

          ## Query Description: "This operation creates the 'notes' table for personal journaling. Data is sensitive and is protected by RLS policies, ensuring strict privacy. This is a safe, data-centric operation."
          
          ## Metadata:
          - Schema-Category: "Data"
          - Impact-Level: "Medium"
          - Requires-Backup: false
          - Reversible: true
          
          ## Structure Details:
          - Table: public.notes
          - Columns: id, user_id, day_id, content, updated_at
          
          ## Security Implications:
          - RLS Status: Enabled
          - Policy Changes: Yes
          - Auth Requirements: Users can only CRUD their own notes.
          
          ## Performance Impact:
          - Indexes: Primary key and a unique index on (user_id, day_id).
          - Triggers: None
          - Estimated Impact: Low, standard CRUD operations.
          */
CREATE TABLE public.notes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  day_id INT NOT NULL,
  content TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, day_id)
);

ALTER TABLE public.notes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own notes."
ON public.notes FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own notes."
ON public.notes FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own notes."
ON public.notes FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

/*
          # Create Quiz Answers Table
          This table stores user's answers to the daily quizzes.

          ## Query Description: "This operation creates the 'quiz_answers' table. User responses are private and secured by RLS policies. This is a safe, data-centric operation."
          
          ## Metadata:
          - Schema-Category: "Data"
          - Impact-Level: "Medium"
          - Requires-Backup: false
          - Reversible: true
          
          ## Structure Details:
          - Table: public.quiz_answers
          - Columns: id, user_id, day_id, question_index, answer, updated_at
          
          ## Security Implications:
          - RLS Status: Enabled
          - Policy Changes: Yes
          - Auth Requirements: Users can only CRUD their own quiz answers.
          
          ## Performance Impact:
          - Indexes: Primary key and a unique index on (user_id, day_id, question_index).
          - Triggers: None
          - Estimated Impact: Low, standard CRUD operations.
          */
CREATE TABLE public.quiz_answers (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  day_id INT NOT NULL,
  question_index INT NOT NULL,
  answer TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, day_id, question_index)
);

ALTER TABLE public.quiz_answers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own quiz answers."
ON public.quiz_answers FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own quiz answers."
ON public.quiz_answers FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own quiz answers."
ON public.quiz_answers FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);
